/**
 * LangChain VectorStore integration for ConceptDB
 */

import { VectorStore } from 'langchain/vectorstores/base';
import { Embeddings } from 'langchain/embeddings/base';
import { Document } from 'langchain/document';
import { ConceptDB } from '../client';
import { Concept } from '../types';

export interface ConceptDBVectorStoreConfig {
  client: ConceptDB;
  collectionName?: string;
}

/**
 * ConceptDB VectorStore for LangChain integration
 */
export class ConceptDBVectorStore extends VectorStore {
  private client: ConceptDB;
  private collectionName: string;
  
  _vectorstoreType(): string {
    return 'conceptdb';
  }
  
  constructor(
    embeddings: Embeddings,
    config: ConceptDBVectorStoreConfig
  ) {
    super(embeddings, config);
    this.client = config.client;
    this.collectionName = config.collectionName || 'langchain';
  }
  
  /**
   * Add documents to ConceptDB
   */
  async addDocuments(documents: Document[]): Promise<void> {
    const texts = documents.map(doc => doc.pageContent);
    const metadatas = documents.map(doc => doc.metadata);
    await this.addVectors([], texts, metadatas);
  }
  
  /**
   * Add vectors to ConceptDB
   */
  async addVectors(
    vectors: number[][],
    documents: string[],
    metadatas?: Record<string, any>[]
  ): Promise<void> {
    const concepts: Array<Omit<Concept, 'id' | 'createdAt' | 'updatedAt'>> = [];
    
    for (let i = 0; i < documents.length; i++) {
      const concept = {
        name: this.extractName(documents[i]),
        description: documents[i],
        metadata: {
          ...metadatas?.[i],
          source: 'langchain',
          collection: this.collectionName
        },
        vector: vectors[i] // Will be generated by ConceptDB if not provided
      };
      
      concepts.push(concept);
    }
    
    // Batch create concepts
    await this.client.concepts.batchCreate(concepts);
  }
  
  /**
   * Similarity search
   */
  async similaritySearch(
    query: string,
    k = 4,
    filter?: Record<string, any>
  ): Promise<Document[]> {
    const results = await this.client.concepts.search({
      query,
      limit: k,
      threshold: 0.5
    });
    
    // Filter results if filter provided
    let filtered = results;
    if (filter) {
      filtered = results.filter(concept => 
        this.matchesFilter(concept.metadata || {}, filter)
      );
    }
    
    // Convert concepts to documents
    return filtered.map(concept => new Document({
      pageContent: concept.description,
      metadata: {
        ...concept.metadata,
        conceptId: concept.id,
        conceptName: concept.name,
        strength: concept.strength
      }
    }));
  }
  
  /**
   * Similarity search with scores
   */
  async similaritySearchWithScore(
    query: string,
    k = 4,
    filter?: Record<string, any>
  ): Promise<[Document, number][]> {
    const results = await this.client.concepts.search({
      query,
      limit: k,
      threshold: 0.5
    });
    
    // Filter results if filter provided
    let filtered = results;
    if (filter) {
      filtered = results.filter(concept => 
        this.matchesFilter(concept.metadata || {}, filter)
      );
    }
    
    // Convert concepts to documents with scores
    return filtered.map(concept => [
      new Document({
        pageContent: concept.description,
        metadata: {
          ...concept.metadata,
          conceptId: concept.id,
          conceptName: concept.name
        }
      }),
      concept.strength || 0.5
    ]);
  }
  
  /**
   * Similarity search by vector
   */
  async similaritySearchVectorWithScore(
    query: number[],
    k: number,
    filter?: Record<string, any>
  ): Promise<[Document, number][]> {
    // ConceptDB handles vector search internally
    // For now, we'll throw an error as direct vector search isn't exposed
    throw new Error(
      'Direct vector search not yet supported. Use similaritySearch with text query instead.'
    );
  }
  
  /**
   * Delete documents
   */
  async delete(params: { ids?: string[] }): Promise<void> {
    if (params.ids) {
      for (const id of params.ids) {
        await this.client.concepts.delete(id);
      }
    }
  }
  
  /**
   * Create a ConceptDBVectorStore from texts
   */
  static async fromTexts(
    texts: string[],
    metadatas: object[] | object,
    embeddings: Embeddings,
    config: ConceptDBVectorStoreConfig
  ): Promise<ConceptDBVectorStore> {
    const docs: Document[] = [];
    
    for (let i = 0; i < texts.length; i++) {
      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
      docs.push(new Document({
        pageContent: texts[i],
        metadata
      }));
    }
    
    return ConceptDBVectorStore.fromDocuments(docs, embeddings, config);
  }
  
  /**
   * Create a ConceptDBVectorStore from documents
   */
  static async fromDocuments(
    docs: Document[],
    embeddings: Embeddings,
    config: ConceptDBVectorStoreConfig
  ): Promise<ConceptDBVectorStore> {
    const store = new ConceptDBVectorStore(embeddings, config);
    await store.addDocuments(docs);
    return store;
  }
  
  /**
   * Create from existing collection
   */
  static async fromExistingCollection(
    embeddings: Embeddings,
    config: ConceptDBVectorStoreConfig
  ): Promise<ConceptDBVectorStore> {
    return new ConceptDBVectorStore(embeddings, config);
  }
  
  /**
   * Enhanced methods for ConceptDB features
   */
  
  /**
   * Get related concepts using ConceptDB's relationship graph
   */
  async getRelatedDocuments(
    conceptId: string,
    relationshipType?: string
  ): Promise<Document[]> {
    const concepts = await this.client.concepts.getRelated(conceptId, relationshipType);
    
    return concepts.map(concept => new Document({
      pageContent: concept.description,
      metadata: {
        ...concept.metadata,
        conceptId: concept.id,
        conceptName: concept.name,
        relationshipType
      }
    }));
  }
  
  /**
   * Analyze text and extract concepts
   */
  async analyzeText(text: string): Promise<{
    concepts: Document[];
    keywords: string[];
    insights: string[];
  }> {
    const analysis = await this.client.concepts.analyze(text);
    
    const conceptDocs = analysis.concepts.map(concept => new Document({
      pageContent: concept.description,
      metadata: {
        conceptId: concept.id,
        conceptName: concept.name,
        strength: concept.strength
      }
    }));
    
    return {
      concepts: conceptDocs,
      keywords: analysis.keywords,
      insights: analysis.insights
    };
  }
  
  /**
   * Execute hybrid query across both PostgreSQL and concept layers
   */
  async hybridSearch(query: string, options?: {
    k?: number;
    preferLayer?: 'auto' | 'postgres' | 'concepts';
    includeMetadata?: boolean;
  }): Promise<Document[]> {
    const result = await this.client.execute(query, {
      preferLayer: options?.preferLayer || 'auto',
      limit: options?.k || 10,
      includeMetadata: options?.includeMetadata
    });
    
    // Convert results to documents
    return result.results.map(item => new Document({
      pageContent: JSON.stringify(item),
      metadata: {
        routingDecision: result.routingDecision,
        confidenceScore: result.confidenceScore,
        ...item
      }
    }));
  }
  
  /**
   * Get concept evolution over time
   */
  async getConceptEvolution(conceptId: string): Promise<{
    timeline: Array<{ date: Date; event: string }>;
    changes: number;
    growth: number;
  }> {
    return await this.client.concepts.getEvolution(conceptId);
  }
  
  /**
   * Helper method to extract name from text
   */
  private extractName(text: string): string {
    // Take first 50 characters or until first sentence
    const firstSentence = text.split(/[.!?]/)[0];
    const name = firstSentence.slice(0, 50);
    return name.length < firstSentence.length ? name + '...' : name;
  }
  
  /**
   * Helper method to check if metadata matches filter
   */
  private matchesFilter(
    metadata: Record<string, any>,
    filter: Record<string, any>
  ): boolean {
    for (const [key, value] of Object.entries(filter)) {
      if (metadata[key] !== value) {
        return false;
      }
    }
    return true;
  }
}

/**
 * Helper function to create ConceptDBVectorStore
 */
export async function createConceptDBVectorStore(
  config: {
    url: string;
    apiKey?: string;
    embeddings: Embeddings;
    collectionName?: string;
  }
): Promise<ConceptDBVectorStore> {
  const client = new ConceptDB({
    url: config.url,
    apiKey: config.apiKey
  });
  
  return new ConceptDBVectorStore(config.embeddings, {
    client,
    collectionName: config.collectionName
  });
}